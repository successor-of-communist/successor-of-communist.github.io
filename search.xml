<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[page_acm_cug2018]]></title>
    <url>%2F2018%2F06%2F18%2Fpage-acm-cug2018%2F</url>
    <content type="text"><![CDATA[Problem B 排序二叉树 直接写二叉树会超时在插入一个数据时，会发现它会放在二叉树上刚好比它大或者刚好比它小的后面，也就是说它的父亲不是刚好比它大就是刚好比它小可以用一个set维护已经插入二叉树的数，然后可以二分搜索到刚好比它大或者刚好比它小的数然后把这个数也插入 Promble E 噩梦中的序列直接暴力DFS Problem H How many bracelets?要用到Polya计数(看挑战书上)一般的模板是有m种颜色，个数任意这个题有3种颜色，每种颜色的个数是给定的，所以单个颜色珍珠的个数必须被n/gcd(k,n)整除,否则的话，会有多种颜色的珍珠组成一个轨迹，而要求的是轨迹上的珍珠颜色都是相同的然后将珍珠的分成gcd(k,n)组，算出有多少种组合上面的是旋转下面说翻转有两种情况：当N为奇数时，可以选择一个点最为对称点，其它的点都是两两对称，所以就是，对称点给一种颜色，其它的就是剩余的颜色的组合当N为偶数时，有两种情况：1选择两个点为对称轴，给这两个点枚举颜色，其它就是剩余颜色组合2选两个边为对称轴，然后组合 Problem K 棋盘游戏bfs棋盘的所有情况 Problem I Galgame中的SL可持久化并查集模板题]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2018%2F06%2F18%2Fpage-acm-template%2F</url>
    <content type="text"><![CDATA[组合数&emsp;打表 主要用这个公式$$C(n,m)=C(n-1,m-1)+C(n-1,m)$$这个的n要求比较小 n&lt;=10,00因为是$O(n^2)$的复杂度 12345678910111213141516171819202122const int M = 10007;const int MAXN = 1000;int C[MAXN+1][MAXN+1];void Initial()&#123; int i,j; for(i=0; i&lt;=MAXN; ++i) &#123; C[0][i] = 0; C[i][0] = 1; &#125; for(i=1; i&lt;=MAXN; ++i) &#123; for(j=1; j&lt;=MAXN; ++j) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % M; &#125;&#125;int Combination(int n, int m)&#123; return C[n][m];&#125; Lucas定理求组合数12345678910111213141516171819202122232425262728293031323334353637typedef long long LL;LL Power_mod(LL a, LL b, LL p)&#123; LL res = 1; while(b!=0) &#123; if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; &#125; return res;&#125;LL Comb(LL a,LL b, LL p)&#123; if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b; LL ans = 1, ca = 1, cb = 1; for(LL i=0; i&lt;b; ++i) &#123; ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; &#125; ans = (ca*Power_mod(cb, p-2, p))%p; return ans;&#125;LL Lucas(int n, int m, int p)&#123; LL ans = 1; while(n &amp;&amp; m &amp;&amp; ans) &#123; ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; &#125; return ans;&#125; 求素数大概百万级的12345678910void init() &#123; memset(v, 0, sizeof(v)); for (int i = 2; i &lt;= maxn; i++) &#123; if (!v[i]) &#123; v[++v[0]] = i; &#125; for (int j = 1; j &lt;= v[0] &amp;&amp; v[j] &lt;= maxn/i ; j++) &#123; v[v[j] * i] = 1; if (i%v[j] == 0) break; &#125; &#125;&#125; 欧拉函数&emsp;直接求欧拉函数1234567891011121314151617int euler(int n)&#123; //返回euler(n) int res=n,a=n; for(int i=2;i*i&lt;=a;i++)&#123;//从小到大尝试n的质因数 if(a%i==0)&#123;//如果i是n的质因数 res=res/i*(i-1);//提了一个1/i出来，先进行除法是为了防止中间数据的溢出 while(a%i==0) a/=i;//欧拉函数只记算一种质因数 &#125; &#125; if(a&gt;1) res=res/a*(a-1);//如果最后还剩因子 return res;&#125;int main()&#123; int x; scanf("%d",&amp;x); printf("%d",euler(x)); return 0;&#125; &emsp; 筛选法打欧拉函数表123456789101112131415161718#define Max 1000001int euler[Max];void Init()&#123; euler[1]=1; for(int i=2;i&lt;Max;i++) euler[i]=i; for(int i=2;i&lt;Max;i++) if(euler[i]==i)//如果i是质数 for(int j=i;j&lt;Max;j+=i) euler[j]=euler[j]/i*(i-1);//提一个1/i,先进行除法是为了防止中间数据的溢出 return ;&#125;int main()&#123; Init(); for(int i=1;i&lt;=100;i++) printf("%d\n",euler[i]); return 0;&#125; 可持久化并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define maxn 200005#define maxm 9000005int root[maxn],v[maxm],ls[maxm],rs[maxm];int cnt;int n,m;void build(int &amp;k,int l,int r)&#123; k=++cnt; if(l==r) &#123; v[k]=l; return; &#125; int mid=(l+r)/2; build(ls[k],l,mid); build(rs[k],mid+1,r);&#125;int query(int k,int l,int r,int pos)&#123; if(l==r) return v[k]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(ls[k],l,mid,pos); else return query(rs[k],mid+1,r,pos);&#125;void insert(int x,int &amp;y,int l,int r,int pos,int val)&#123; y=++cnt; if(l==r) &#123; v[y]=val; return; &#125; int mid=(l+r)&gt;&gt;1; ls[y]=ls[x]; rs[y]=rs[x]; if(pos&lt;=mid) insert(ls[x],ls[y],l,mid,pos,val); else insert(rs[x],rs[y],mid+1,r,pos,val);&#125;int find(int &amp;r,int x)&#123; int tmp=query(r,1,n,x); if(tmp==x) return x; else &#123; int ret=find(r,tmp); insert(r,r,1,n,x,ret); return ret; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(root[0],1,n); for(int i=1;i&lt;=m;i++) &#123; int f; cin&gt;&gt;f; if(f==1) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int fx=find(root[i-1],x),fy=find(root[i-1],y); if(fx==fy) root[i]=root[i-1]; else insert(root[i-1],root[i],1,n,fx,fy); &#125; else if(f==2) &#123; int x; cin&gt;&gt;x; root[i]=root[x]; &#125; else&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; root[i]=root[i-1]; int fx=find(root[i],x),fy=find(root[i],y); if(fx==fy) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; 最短路&emsp;Dijkstra 使用优先队列优化Dijkstra算法 复杂度O(ElongE) 注意对vector E[MAXN]进行初始化后加边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qNode&#123; int v; int c; qNode(int v = 0, int c = 0) : v(v), c(c) &#123;&#125; bool operator &lt; (const qNode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge&#123; int v; int cost; Edge(int v = 0, int cost = 0) : v(v), cost(cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN]; // 最短路距离void Dijkstra(int n, int start) // 点的编号从1开始&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); priority_queue&lt;qNode&gt; que; while (!que.empty()) &#123; que.pop(); &#125; dist[start] = 0; que.push(qNode(start, 0)); qNode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) &#123; continue; &#125; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qNode(v, dist[v])); &#125; &#125; &#125;&#125;void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125; &emsp; SPFA 时间复杂度O(kE) 可判负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge&#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125;bool vis[MAXN]; // 在队列标志int cnt[MAXN]; // 每个点的入列队次数int dist[MAXN];bool SPFA(int start, int n)&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; while (!que.empty()) &#123; que.pop(); &#125; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) &#123; return false; // cnt[i]为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; &#125; return true;&#125; 缩点（强连通分量）&emsp;tarjanLCApolya123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * m种颜色涂n个点的环 * 只有旋转a/n种只有翻转b/n种 * 两者都有(a+b)/(n*2)种 * n,m&lt;=1e9 */int prime[100005];//求出1~1e5的素数const int mod=1000000007;long long mod_pow(int a,int b)&#123; long long ans=1; long long aa=a; int bb=b; while(b) &#123; if(b&amp;1) ans=(ans*aa)%mod; aa=(aa*aa)%mod; b/=2; &#125; return ans;&#125;void solve(int n,int m)&#123; long long i=1; long long res=0; for(;i*i&lt;n;i++) &#123; if(n%i==0) &#123; int tmp=i; int euler=i; for(int j=1;j&lt;prime[0];j++) &#123; if(tmp%prime[j]==0) &#123; euler=euler/prime[j]*(prime[j]-1); while(tmp%prime[j]==0) tmp/=prime[j]; &#125; &#125; res+=euler*mod_pow(m,n/i)%mod; res%=mod; &#125; &#125; printf("%lld\n",res);&#125;/* * 颜色数固定，每种颜色的量（就是能涂多少个点）给定 * 下面这个代码是3种颜色，每种颜色的分别个数是x,y,z */long long C[50][50];void init()&#123; C[0][0]=C[1][0]=C[1][1]=1; for(int i=2;i&lt;50;i++) &#123; C[i][0]=C[i][i]=1; for(int j=1;j&lt;i;j++) &#123; C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; &#125;&#125;int gcd(int a,int b)&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int tmp[3];long long cal(int len)&#123; long long ans=1; int sum=0; for(int i=0;i&lt;3;i++) &#123; if(tmp[i]%len) return 0; tmp[i]/=len; sum+=tmp[i]; &#125; for(int i=0;i&lt;2;i++) &#123; ans*=C[sum][tmp[i]]; sum-=tmp[i]; &#125; return ans;&#125;int main()&#123; init(); int t; cin&gt;&gt;t; while(t--) &#123; int x,y,z; long long ans=0; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; int n=x+y+z; for(int i=1;i&lt;=n;i++) &#123; tmp[0]=x; tmp[1]=y; tmp[2]=z; ans+=cal(n/gcd(i,n)); &#125; if(n&amp;1) &#123; for(int i=0;i&lt;3;i++) &#123; tmp[0]=x; tmp[1]=y; tmp[2]=z; tmp[i]--; ans+=cal(2)*n; &#125; &#125; else &#123; for(int i=0;i&lt;3;i++) &#123; for(int j=0;j&lt;3;j++) &#123; tmp[0]=x; tmp[1]=y; tmp[2]=z; tmp[i]--; tmp[j]--; if(tmp[i]&lt;0||tmp[j]&lt;0) continue; ans+=cal(2)*n/2; &#125; &#125; tmp[0]=x; tmp[1]=y; tmp[2]=z; ans+=cal(2)*n/2; &#125; ans=ans/(2*n); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装opencv]]></title>
    <url>%2F2018%2F06%2F17%2Fpage_opencv%2F</url>
    <content type="text"><![CDATA[1.去官网下载opencv，在本教程中选用的时opencv3.4.1，其他版本的配置方法异曲同工下载地址,选择sources版本 2.解压下载下来的zip包1unzip opencv-3.4.1.zip 3.进入到解压后的文件包中 4.安装依赖库和cmake ，如果提醒需要apt-get update，那就先sudo su进入root权限，再sudo apt-get update，然后在执行下面命令123sudo apt-get install cmake sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev 5.安装完cmake之后执行命令 ,创建编译文件夹，不创建的会提示fatal:In-source builds are not allowed.12mkdir my_build_dircd my_build_dir 6.cmake一下1cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 注意：如果已经在新的文件夹中编译，但是还会出现之前的报错，把cmakecache.txt删了再编译 期间可能会下载一个东西，等待一会儿就OK 7.执行命令，漫长的编译过程1sudo make 8.执行命令1sudo make install 9.sudo make install 执行完毕后OpenCV编译过程就结束了，接下来就需要配置一些OpenCV的编译环境首先将OpenCV的库添加到路径，从而可以让系统找到1sudo gedit /etc/ld.so.conf.d/opencv.conf 执行此命令后打开的可能是一个空白的文件，不用管，只需要在文件末尾添加 /usr/local/lib 10.执行如下命令使得刚才的配置路径生效1sudo ldconfig 过程中没有问题，有问题的可以看下最下面的参考网址 11.配置bash1sudo gedit /etc/bash.bashrc 在最末尾添加 PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH 保存，执行如下命令使得配置生效1source /etc/bash.bashrc 更新1sudo updatedb 12.至此所有的配置都已经完成下面用一个小程序测试一下 找到cd到opencv-3.4.1/samples/cpp/example_cmake目录下我们可以看到这个目录里官方已经给出了一个cmake的example我们可以拿来测试下按顺序执行123cmake .make./opencv_example 即可看到打开了摄像头，在左上角有一个hello opencv即表示配置成功 13.测试随便找个代码试一下如果提示 fatal:core/core.hpp file not find前面加opencv2/ #include &lt;opencv2/core/core.hpp&gt;opencv的头文件都类似 参考地址：https://blog.csdn.net/cocoaqin/article/details/78163171]]></content>
      <tags>
        <tag>opencv</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim+markdown]]></title>
    <url>%2F2018%2F06%2F17%2Fvim_markdown%2F</url>
    <content type="text"><![CDATA[没有vim感觉生活不能自理install三个插件:语法高亮插件vim-markdown实时预览插件markdown-preview.vim可以预览数学公式插件mathjax-support-for-mkdp后两个是在一起的，说明文档写的很清楚 我用的vundle管理vim插件只用添加 1234Plugin 'godlygeek/tabular'Plugin 'plasticboy/vim-markdown'Plugin 'iamcco/mathjax-support-for-mkdp'Plugin 'iamcco/markdown-preview.vim' 然后:PluginInstall OK结束]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>vim</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用插件支持MathJax]]></title>
    <url>%2F2018%2F06%2F17%2Fpage_hexo_mathjax%2F</url>
    <content type="text"><![CDATA[MathJax是使用LaTeX方式输入数学公式的好工具。Hexo虽然可以直接使用mathjax，但是存在一些不方便之处。使用hexo-math这个插件可以大大方便使用。 在hexo安装目录下执行 1npm install hexo-math --save 然后编辑站点根目录下的_config.yml，添加 123456math: engine: 'mathjax' # or 'katex' mathjax: src: custom_mathjax_source config: # MathJax config 之后进入theme的目录，编辑主题的_config.yml，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成 12mathjax: enable: true OK这样就好了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canny边缘检测]]></title>
    <url>%2F2018%2F06%2F04%2Fpage_canny%2F</url>
    <content type="text"><![CDATA[参考地址https://blog.csdn.net/dcrmg/article/details/52344902]]></content>
      <categories>
        <category>ComputerVision</category>
      </categories>
      <tags>
        <tag>ComputerVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Hexo配置]]></title>
    <url>%2F2018%2F05%2F31%2Fpage_hexo%2F</url>
    <content type="text"><![CDATA[安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 Wget:1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1$ nvm install stable ##安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 初探 Hexo先要初始化一个目录123$ hexo init &lt;filename&gt;$ hexo g$ hexo s //调试 执行后会出现INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 浏览器登录网址就可以看到刚创建的博客 将hexo博客部署到github上申请github帐号创建仓库：yourname.github.ioyourname是你的账户名 修改配置文件blog/_config.yml，修改deploy项（在文件最下面）的内容，如下所示：123456789# Deployment 注释## Docs: https://hexo.io/docs/deployment.htmldeploy: # 类型 type: git # 仓库 repo: git@github.com:yourname/yourname.github.io.git # 分支 branch: master 输入下面的命令将hexo博客部署到github中：123456# 清空静态页面hexo clean# 生成静态页面hexo generate# 部署 hexo deploy next主题配置https://zhuanlan.zhihu.com/p/30836436https://blog.csdn.net/qq_33699981/article/details/72716951]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
