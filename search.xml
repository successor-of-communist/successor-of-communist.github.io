<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu18.04配置opencv3.4.1+opencv-contrib]]></title>
    <url>%2F2018%2F06%2F20%2Fpage-opencv341-contrib%2F</url>
    <content type="text"><![CDATA[搞了很长时间，终于成功了参考网址上面也有16.04的教程 上面的网址说的很清楚我就简单粗暴点他写的是python+opencv,我用的是c++，所以略去了不必要的1234567891011121314151617181920212223242526272829303132sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential cmake unzip pkg-configsudo apt-get install libjpeg-dev libpng-dev libtiff-devsudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-devsudo apt-get install libxvidcore-dev libx264-devsudo apt-get install libgtk-3-devsudo apt-get install libatlas-base-dev gfortransudo apt-get install python3-devcd ~wget -O opencv.zip https://github.com/opencv/opencv/archive/3.4.1.zipwget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/3.4.1.zipunzip opencv.zipunzip opencv_contrib.zipcd ~/opencv-3.4.1/mkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=RELEASE \ -D CMAKE_INSTALL_PREFIX=/usr/local \ -D INSTALL_PYTHON_EXAMPLES=ON \ -D INSTALL_C_EXAMPLES=OFF \ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib-3.4.1/modules \ -D BUILD_EXAMPLES=ON ..make -j4sudo make installsudo ldconfig 最后配置编译环境可以参考我的另一篇文章ubuntu16.04配置opencv]]></content>
      <categories>
        <category>opencv</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>ubuntu18.04</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题目总结]]></title>
    <url>%2F2018%2F06%2F20%2Fpage-acm-index%2F</url>
    <content type="text"><![CDATA[最短路hdu1593&emsp;hdu2433&emsp;hdu2112&emsp;hdu2544 第K短路poj2449 拓扑排序hdu2647 强连通分量poj2186&emsp;poj1236&emsp;poj1904&emsp;hdu1269+&emsp;hdu2767+&emsp;hdu3836+&emsp;hdu1827++&emsp;hdu3072++&emsp; 双连通分量hdu2460 2-satpoj3207hdu3062&emsp;1824&emsp;3622 LCApoj1330 网络流uva12264&emsp;uva11082&emsp;uva10735&emsp;uva1349hdu1532&emsp;hdu3549&emsp;hdu3572&emsp;hdu2732]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cug2018校赛]]></title>
    <url>%2F2018%2F06%2F18%2Fpage-acm-cug2018%2F</url>
    <content type="text"><![CDATA[Problem B 排序二叉树 直接写二叉树会超时在插入一个数据时，会发现它会放在二叉树上刚好比它大或者刚好比它小的后面，也就是说它的父亲不是刚好比它大就是刚好比它小可以用一个set维护已经插入二叉树的数，然后可以二分搜索到刚好比它大或者刚好比它小的数然后把这个数也插入 Promble E 噩梦中的序列直接暴力DFS Problem H How many bracelets?要用到Polya计数(看挑战书上)一般的模板是有m种颜色，个数任意这个题有3种颜色，每种颜色的个数是给定的，所以单个颜色珍珠的个数必须被n/gcd(k,n)整除,否则的话，会有多种颜色的珍珠组成一个轨迹，而要求的是轨迹上的珍珠颜色都是相同的然后将珍珠的分成gcd(k,n)组，算出有多少种组合上面的是旋转下面说翻转有两种情况：当N为奇数时，可以选择一个点最为对称点，其它的点都是两两对称，所以就是，对称点给一种颜色，其它的就是剩余的颜色的组合当N为偶数时，有两种情况：1选择两个点为对称轴，给这两个点枚举颜色，其它就是剩余颜色组合2选两个边为对称轴，然后组合 Problem K 棋盘游戏bfs棋盘的所有情况 Problem I Galgame中的SL可持久化并查集模板题]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2018%2F06%2F18%2Fpage-acm-template%2F</url>
    <content type="text"><![CDATA[组合数&emsp;打表 主要用这个公式$$C(n,m)=C(n-1,m-1)+C(n-1,m)$$这个的n要求比较小 n&lt;=10,00因为是$O(n^2)$的复杂度 12345678910111213141516171819202122const int M = 10007;const int MAXN = 1000;int C[MAXN+1][MAXN+1];void Initial()&#123; int i,j; for(i=0; i&lt;=MAXN; ++i) &#123; C[0][i] = 0; C[i][0] = 1; &#125; for(i=1; i&lt;=MAXN; ++i) &#123; for(j=1; j&lt;=MAXN; ++j) C[i][j] = (C[i-1][j] + C[i-1][j-1]) % M; &#125;&#125;int Combination(int n, int m)&#123; return C[n][m];&#125; Lucas定理求组合数12345678910111213141516171819202122232425262728293031323334353637typedef long long LL;LL Power_mod(LL a, LL b, LL p)&#123; LL res = 1; while(b!=0) &#123; if(b&amp;1) res = (res*a)%p; a = (a*a)%p; b &gt;&gt;= 1; &#125; return res;&#125;LL Comb(LL a,LL b, LL p)&#123; if(a &lt; b) return 0; if(a == b) return 1; if(b &gt; a-b) b = a-b; LL ans = 1, ca = 1, cb = 1; for(LL i=0; i&lt;b; ++i) &#123; ca = (ca*(a-i))%p; cb = (cb*(b-i))%p; &#125; ans = (ca*Power_mod(cb, p-2, p))%p; return ans;&#125;LL Lucas(int n, int m, int p)&#123; LL ans = 1; while(n &amp;&amp; m &amp;&amp; ans) &#123; ans = (ans * Comb(n%p, m%p, p))%p; n /= p; m /= p; &#125; return ans;&#125; 求素数大概百万级的12345678910void init() &#123; memset(v, 0, sizeof(v)); for (int i = 2; i &lt;= maxn; i++) &#123; if (!v[i]) &#123; v[++v[0]] = i; &#125; for (int j = 1; j &lt;= v[0] &amp;&amp; v[j] &lt;= maxn/i ; j++) &#123; v[v[j] * i] = 1; if (i%v[j] == 0) break; &#125; &#125;&#125; 欧拉函数小于n的正整数中与n互质的数的数目 &emsp;直接求欧拉函数1234567891011121314151617int euler(int n)&#123; //返回euler(n) int res=n,a=n; for(int i=2;i*i&lt;=a;i++)&#123;//从小到大尝试n的质因数 if(a%i==0)&#123;//如果i是n的质因数 res=res/i*(i-1);//提了一个1/i出来，先进行除法是为了防止中间数据的溢出 while(a%i==0) a/=i;//欧拉函数只记算一种质因数 &#125; &#125; if(a&gt;1) res=res/a*(a-1);//如果最后还剩因子 return res;&#125;int main()&#123; int x; scanf("%d",&amp;x); printf("%d",euler(x)); return 0;&#125; &emsp; 筛选法打欧拉函数表123456789101112131415161718#define Max 1000001int euler[Max];void Init()&#123; euler[1]=1; for(int i=2;i&lt;Max;i++) euler[i]=i; for(int i=2;i&lt;Max;i++) if(euler[i]==i)//如果i是质数 for(int j=i;j&lt;Max;j+=i) euler[j]=euler[j]/i*(i-1);//提一个1/i,先进行除法是为了防止中间数据的溢出 return ;&#125;int main()&#123; Init(); for(int i=1;i&lt;=100;i++) printf("%d\n",euler[i]); return 0;&#125; 可持久化并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#define maxn 200005#define maxm 9000005int root[maxn],v[maxm],ls[maxm],rs[maxm];int cnt;int n,m;void build(int &amp;k,int l,int r)&#123; k=++cnt; if(l==r) &#123; v[k]=l; return; &#125; int mid=(l+r)/2; build(ls[k],l,mid); build(rs[k],mid+1,r);&#125;int query(int k,int l,int r,int pos)&#123; if(l==r) return v[k]; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(ls[k],l,mid,pos); else return query(rs[k],mid+1,r,pos);&#125;void insert(int x,int &amp;y,int l,int r,int pos,int val)&#123; y=++cnt; if(l==r) &#123; v[y]=val; return; &#125; int mid=(l+r)&gt;&gt;1; ls[y]=ls[x]; rs[y]=rs[x]; if(pos&lt;=mid) insert(ls[x],ls[y],l,mid,pos,val); else insert(rs[x],rs[y],mid+1,r,pos,val);&#125;int find(int &amp;r,int x)&#123; int tmp=query(r,1,n,x); if(tmp==x) return x; else &#123; int ret=find(r,tmp); insert(r,r,1,n,x,ret); return ret; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; build(root[0],1,n); for(int i=1;i&lt;=m;i++) &#123; int f; cin&gt;&gt;f; if(f==1) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int fx=find(root[i-1],x),fy=find(root[i-1],y); if(fx==fy) root[i]=root[i-1]; else insert(root[i-1],root[i],1,n,fx,fy); &#125; else if(f==2) &#123; int x; cin&gt;&gt;x; root[i]=root[x]; &#125; else&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; root[i]=root[i-1]; int fx=find(root[i],x),fy=find(root[i],y); if(fx==fy) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; 最短路&emsp;Dijkstra 使用优先队列优化Dijkstra算法 复杂度O(ElongE) 注意对vector E[MAXN]进行初始化后加边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int INF = 0x3f3f3f3f;const int MAXN = 1000010;struct qNode&#123; int v; int c; qNode(int v = 0, int c = 0) : v(v), c(c) &#123;&#125; bool operator &lt; (const qNode &amp;r) const &#123; return c &gt; r.c; &#125;&#125;;struct Edge&#123; int v; int cost; Edge(int v = 0, int cost = 0) : v(v), cost(cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];bool vis[MAXN];int dist[MAXN]; // 最短路距离void Dijkstra(int n, int start) // 点的编号从1开始&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); priority_queue&lt;qNode&gt; que; while (!que.empty()) &#123; que.pop(); &#125; dist[start] = 0; que.push(qNode(start, 0)); qNode tmp; while (!que.empty()) &#123; tmp = que.top(); que.pop(); int u = tmp.v; if (vis[u]) &#123; continue; &#125; vis[u] = true; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; int cost = E[u][i].cost; if (!vis[v] &amp;&amp; dist[v] &gt; dist[u] + cost) &#123; dist[v] = dist[u] + cost; que.push(qNode(v, dist[v])); &#125; &#125; &#125;&#125;void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125; &emsp; SPFA 时间复杂度O(kE) 可判负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int MAXN = 1010;const int INF = 0x3f3f3f3f;struct Edge&#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN];void addEdge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125;bool vis[MAXN]; // 在队列标志int cnt[MAXN]; // 每个点的入列队次数int dist[MAXN];bool SPFA(int start, int n)&#123; memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); vis[start] = true; dist[start] = 0; queue&lt;int&gt; que; while (!que.empty()) &#123; que.pop(); &#125; que.push(start); memset(cnt, 0, sizeof(cnt)); cnt[start] = 1; while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &gt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) &#123; return false; // cnt[i]为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; &#125; return true;&#125; 缩点（强连通分量）kuangbin 数据结构树状数组一维单点修改+区间查询12345678910111213141516171819202122232425262728const int maxn=1e6;int sum[maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int p,int x)&#123; while(p&lt;=n) &#123; sum[p]+=x; p+=lowbit(p); &#125;&#125;int query(int p)&#123; int res=0; while(p) &#123; res+=sum[p]; p-=lowbit(p); &#125; return res;&#125;int range_query(int l,int r)&#123; return query(r)-query(l-1);&#125; 区间修改+单点查询1234567891011121314151617181920212223242526272829const int maxn=1e6;int sum[maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int p,int x)&#123; while(p&lt;=n) &#123; sum[p]+=x; p+=lowbit(p); &#125;&#125;void range_update(int l,int r,int x)&#123; update(l,x); update(r+1,-x);&#125;int query(int p)&#123; int res=0; while(p) &#123; res+=sum[p]; p-=lowbit(p); &#125; return res;&#125; 区间修改+区间查询1234567891011121314151617181920212223242526272829303132const int maxn=1e6;int sum[maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int p,int x)&#123; for(int i=p;i&lt;=n;i+=lowbit(i)) &#123; sum1[i]+=x; sum2[i]+=x*p; &#125;&#125;void range_update(int l,int r,int x)&#123; update(l,x); update(r+1,-x);&#125;int query(int p)&#123; int res=0; for(int i=p;i&gt;0;i-=lowbit(i)) &#123; res+=(p+1)*sum1[i]-sum2[i]; &#125; return res;&#125;int range_query(int l,int r)&#123; return query(r)-query(l-1);&#125; 二维单点修改+区间查询123456789101112131415161718192021222324252627282930313233343536373839const int maxn=1e3;int sum[maxn][maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int x,int y,int z)&#123; int my=y; while(x&lt;=n) &#123; y=my; while(y&lt;=n) &#123; sum[x][y]+=z; y+=lowbit(y); &#125; x+=lowbit(x); &#125;&#125;int query(int x,int y)&#123; int res=0,my=y; while(x) &#123; y=my; while(y) &#123; res+=sum[x][y]; y-=lowbit(y); &#125; x-=lowbit(x); &#125; return res;&#125;int range_query(int xa,int ya,int xb,int yb)&#123; return query(xb,yb)-query(xa-1,ya-1);&#125; 区间修改+单点查询123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn=1e3;int sum[maxn][maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int x,int y,int z)&#123; int my=y; while(x&lt;=n) &#123; y=my; while(y&lt;=n) &#123; sum[x][y]+=z; y+=lowbit(y); &#125; x+=lowbit(x); &#125;&#125;void range_update(int xa,int ya,int xb,int yb,int z)&#123; update(xa,ya,z); update(xa,yb+1,-z); update(xb+1,ya,-z); update(xb+1,yb+1,z);&#125;int query(int x,int y)&#123; int res=0,my=y; while(x) &#123; y=my; while(y) &#123; res+=sum[x][y]; y-=lowbit(y); &#125; x-=lowbit(x); &#125; return res;&#125; 区间修改+区间查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int maxn=1e3;int sum1[maxn][maxn];int sum2[maxn][maxn];int sum3[maxn][maxn];int sum4[maxn][maxn];int lowbit(int x)&#123; return x&amp;-x;&#125;void update(int x,int y,int z)&#123; int my=y; while(x&lt;=n) &#123; y=my; while(y&lt;=n) &#123; sum1[x][y]+=z; sum2[x][y]+=z*x; sum3[x][y]+=z*y; sum4[x][y]+=z*x*y; y+=lowbit(y); &#125; x+=lowbit(x); &#125;&#125;void range_update(int xa,int ya,int xb,int yb,int z)&#123; update(xa,ya,z); update(xa,yb+1,-z); update(xb+1,ya,-z); update(xb+1,yb+1,z);&#125;int query(int x,int y)&#123; int res=0; for(int i=x;i;i-=lowbit(i)) &#123; for(int j=y;j;j-=lowbit(j)) &#123; res+=sum1[i][j]*(x+1)*(y+1) -(y+1)*sum2[i][j] -(x+1)*sum3[i][j] +sum4[i][j]; &#125; &#125; return res;&#125;int range_query(int xa,int ya,int xb,int yb)&#123; return query(xb,yb)-query(xb,ya-1)-query(xa-1,yb)+query(xa-1,ya-1);&#125; 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const int maxn=1e5+5;int ans[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2],a[maxn];void pushup(int rt)&#123; ans[rt]=ans[rt&lt;&lt;1]+ans[rt&lt;&lt;1|1];&#125;void build(int l,int r,int rt)&#123; if(l==r) &#123; ans[rt]=a[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(l,mid,rt&lt;&lt;1); build(mid+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;void pushdown(int rt,int ln,int rn)//ln表示左子树元素节点的个数，rn表示右子树元素节点的个数&#123; if(lazy[rt]) &#123; lazy[rt&lt;&lt;1]+=lazy[rt]; lazy[rt&lt;&lt;1|1]+=lazy[rt]; ans[rt&lt;&lt;1]+=lazy[rt]*ln; ans[rt&lt;&lt;1|1]+=lazy[rt]*rn; lazy[rt]=0; &#125;&#125;//单点更新void update(int pos,int c,int l,int r,int rt)&#123; if(l==r) &#123; ans[rt]+=c; return; &#125; int mid=(l+r)&gt;&gt;1; //pushdown(rt,mid-l+1,r-mid);若既有点更新又有区间更新，需要这句话 if(pos&lt;=mid) update(pos,c,l,mid,rt&lt;&lt;1); else update(pos,c,mid+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;//区间更新void range_update(int l,int r,int c,int L,int R,int rt)&#123; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; ans[rt]+=c*(R-L+1); lazy[rt]+=c; return; &#125; int mid=(L+R)&gt;&gt;1; pushdown(rt,mid-l+1,r-mid); if(l&lt;=mid) range_update(l,r,c,L,mid,rt&lt;&lt;1); if(r&gt;mid) range_update(l,r,c,mid+1,R,rt&lt;&lt;1|1); pushup(rt);&#125;//区间查询int range_query(int l,int r,int L,int R,int rt)&#123; if(l&lt;=L&amp;&amp;R&lt;=r) return ans[rt]; int mid=(L+R)&gt;&gt;1; pushdown(rt,mid-l+1,r-mid); int ANS=0; if(l&lt;=mid) ANS+=range_query(l,r,L,mid,rt&lt;&lt;1); if(r&gt;mid) ANS+=range_query(l,r,mid+1,R,rt&lt;&lt;1|1); return ANS;&#125;//建树build(1,n,1);//点更新update(pos,c,1,n,1);//区间更新range_update(l,r,c,1,n,1);//区间查询range_query(l,r,1,n,1); 划分树求区间第k大数和区间前k大数的和-其它数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const int MAXN=200010;int tree[20][MAXN];int sorted[MAXN];int toleft[20][MAXN];long long sum[20][MAXN];void build(int l,int r,int dep)&#123; if(l==r) &#123; sum[dep][l]=tree[dep][l]; return; &#125; int mid=(l+r)&gt;&gt;1; int same=mid-l+1;//same表示等于中间值且到左边的数的个数 for(int i=l;i&lt;=r;i++) &#123; if(tree[dep][i]&lt;sorted[mid]) same--; sum[dep][i]=tree[dep][i]; if(i&gt;l)sum[dep][i]+=sum[dep][i-1]; &#125; int lpos=l; int rpos=mid+1; for(int i=l;i&lt;=r;i++) &#123; if(tree[dep][i]&lt;sorted[mid])//去左边 &#123; tree[dep+1][lpos++]=tree[dep][i]; &#125; else if(tree[dep][i]==sorted[mid]&amp;&amp;same&gt;0)//去左边 &#123; tree[dep+1][lpos++]=tree[dep][i]; same--; &#125; else//去右边 tree[dep+1][rpos++]=tree[dep][i]; toleft[dep][i]=toleft[dep][l-1]+lpos-l;//从1到i放左边的个数 &#125; build(l,mid,dep+1);//递归建树 build(mid+1,r,dep+1);&#125;long long ans;int query(int L,int R,int l,int r,int dep,int k)&#123; if(l==r)return tree[dep][l]; int mid=(L+R)&gt;&gt;1; int cnt=toleft[dep][r]-toleft[dep][l-1]; int ss=toleft[dep][l-1]-toleft[dep][L-1];//L到l-1放在左子树的个数 int ee=l-L-ss; //L到l-1放到右子树的个数 int s=toleft[dep][r]-toleft[dep][l-1]; //小区间内放到左子树的个数 int e=r-l+1-s; //小区间放到右子树的个数 if(cnt&gt;=k) &#123; if(e&gt;0) &#123; if(ee&gt;0)ans+=sum[dep+1][mid+e+ee]-sum[dep+1][mid+ee]; else ans+=sum[dep+1][mid+e]; &#125; //L+查询区间前去左边的数的个数 int newl=L+toleft[dep][l-1]-toleft[dep][L-1]; //左端点+查询区间会分入左边的数的个数 int newr=newl+cnt-1; return query(L,mid,newl,newr,dep+1,k);//注意 &#125; else &#123; if(s&gt;0) &#123; if(ss&gt;0)ans-=sum[dep+1][L+ss+s-1]-sum[dep+1][L+ss-1]; else ans-=sum[dep+1][L+s-1]; &#125; //r+区间后分入左边的数的个数 int newr=r+toleft[dep][R]-toleft[dep][r]; //右端点减去区间分入右边的数的个数 int newl=newr-(r-l-cnt); return query(mid+1,R,newl,newr,dep+1,k-cnt);//注意 &#125;&#125;int main()&#123; int t; int n,q; scanf("%d",&amp;t); int cou=0; while(t--) &#123; scanf("%d",&amp;n); int l,r; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;tree[0][i]); sorted[i]=tree[0][i]; &#125; sort(sorted+1,sorted+n+1); build(1,n,0); scanf("%d",&amp;q); printf("Case #%d:\n",++cou); for(int i=0;i&lt;q;i++) &#123; scanf("%d%d",&amp;l,&amp;r); l++; r++; ans=0; int ret=query(1,n,l,r,0,(r-l)/2+1); if((r-l+1)%2==0) ans-=ret; printf("%lld\n",ans); &#125; printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 安装opencv]]></title>
    <url>%2F2018%2F06%2F17%2Fpage_opencv%2F</url>
    <content type="text"><![CDATA[1.去官网下载opencv，在本教程中选用的时opencv3.4.1，其他版本的配置方法异曲同工下载地址,选择sources版本 2.解压下载下来的zip包1unzip opencv-3.4.1.zip 3.进入到解压后的文件包中 4.安装依赖库和cmake ，如果提醒需要apt-get update，那就先sudo su进入root权限，再sudo apt-get update，然后在执行下面命令123sudo apt-get install cmake sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev 5.安装完cmake之后执行命令 ,创建编译文件夹，不创建的会提示fatal:In-source builds are not allowed.12mkdir my_build_dircd my_build_dir 6.cmake一下1cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 注意：如果已经在新的文件夹中编译，但是还会出现之前的报错，把cmakecache.txt删了再编译 期间可能会下载一个东西，等待一会儿就OK 7.执行命令，漫长的编译过程1sudo make 8.执行命令1sudo make install 9.sudo make install 执行完毕后OpenCV编译过程就结束了，接下来就需要配置一些OpenCV的编译环境首先将OpenCV的库添加到路径，从而可以让系统找到1sudo gedit /etc/ld.so.conf.d/opencv.conf 执行此命令后打开的可能是一个空白的文件，不用管，只需要在文件末尾添加 /usr/local/lib 10.执行如下命令使得刚才的配置路径生效1sudo ldconfig 过程中没有问题，有问题的可以看下最下面的参考网址 11.配置bash1sudo gedit /etc/bash.bashrc 在最末尾添加 PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH 保存，执行如下命令使得配置生效1source /etc/bash.bashrc 更新1sudo updatedb 12.至此所有的配置都已经完成下面用一个小程序测试一下 找到cd到opencv-3.4.1/samples/cpp/example_cmake目录下我们可以看到这个目录里官方已经给出了一个cmake的example我们可以拿来测试下按顺序执行123cmake .make./opencv_example 即可看到打开了摄像头，在左上角有一个hello opencv即表示配置成功 13.测试随便找个代码试一下如果提示 fatal:core/core.hpp file not find前面加opencv2/ #include &lt;opencv2/core/core.hpp&gt;opencv的头文件都类似 参考地址：https://blog.csdn.net/cocoaqin/article/details/78163171]]></content>
      <tags>
        <tag>opencv</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim+markdown]]></title>
    <url>%2F2018%2F06%2F17%2Fvim_markdown%2F</url>
    <content type="text"><![CDATA[没有vim感觉生活不能自理install三个插件:语法高亮插件vim-markdown实时预览插件markdown-preview.vim可以预览数学公式插件mathjax-support-for-mkdp后两个是在一起的，说明文档写的很清楚 我用的vundle管理vim插件只用添加 1234Plugin 'godlygeek/tabular'Plugin 'plasticboy/vim-markdown'Plugin 'iamcco/mathjax-support-for-mkdp'Plugin 'iamcco/markdown-preview.vim' 然后:PluginInstall OK结束]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>vim</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用插件支持MathJax]]></title>
    <url>%2F2018%2F06%2F17%2Fpage_hexo_mathjax%2F</url>
    <content type="text"><![CDATA[MathJax是使用LaTeX方式输入数学公式的好工具。Hexo虽然可以直接使用mathjax，但是存在一些不方便之处。使用hexo-math这个插件可以大大方便使用。 在hexo安装目录下执行 1npm install hexo-math --save 然后编辑站点根目录下的_config.yml，添加 123456math: engine: 'mathjax' # or 'katex' mathjax: src: custom_mathjax_source config: # MathJax config 之后进入theme的目录，编辑主题的_config.yml，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成 12mathjax: enable: true OK这样就好了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canny边缘检测]]></title>
    <url>%2F2018%2F06%2F04%2Fpage_canny%2F</url>
    <content type="text"><![CDATA[参考地址https://blog.csdn.net/dcrmg/article/details/52344902]]></content>
      <categories>
        <category>ComputerVision</category>
      </categories>
      <tags>
        <tag>ComputerVision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Hexo配置]]></title>
    <url>%2F2018%2F05%2F31%2Fpage_hexo%2F</url>
    <content type="text"><![CDATA[安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 Wget:1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1$ nvm install stable ##安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 初探 Hexo先要初始化一个目录123$ hexo init &lt;filename&gt;$ hexo g$ hexo s //调试 执行后会出现INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 浏览器登录网址就可以看到刚创建的博客 将hexo博客部署到github上申请github帐号创建仓库：yourname.github.ioyourname是你的账户名 修改配置文件blog/_config.yml，修改deploy项（在文件最下面）的内容，如下所示：123456789# Deployment 注释## Docs: https://hexo.io/docs/deployment.htmldeploy: # 类型 type: git # 仓库 repo: git@github.com:yourname/yourname.github.io.git # 分支 branch: master 输入下面的命令将hexo博客部署到github中：123456# 清空静态页面hexo clean# 生成静态页面hexo generate# 部署 hexo deploy next主题配置https://zhuanlan.zhihu.com/p/30836436https://blog.csdn.net/qq_33699981/article/details/72716951]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
